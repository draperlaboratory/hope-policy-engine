# Tagging Tools

This directory contains code for two base level tagging utilities, that can be used generically
to generate tagging information for most policies.  The generated tagging information is used by
the Renode based validator to set up the initial state of tags for an application.

The utilities are intended to provide flexibility for experimentation with policies.  They can
be used to generate tagging information for arbitrary memory locations.

There are scripts that are layered on top of these base utilities that provide a single point of
control for generating tagging information for applications.

The idea behind using generic tagging utilities is to allow for the combination of hetergeneous
sources of information for applying tags to an application.  One set of data could come from the
compiler, while another might come from some external specification for marking, say, some particular
symbols in an application.

# Utilities

## `md_range`

```
usage: md_range <policy_dir> <range_file> <tag_file>
```

* `policy_dir` is the directory into which the policy was generated by the policy tool.
* `range_file` is the name of a text file containing range specifications to tag.
* `tag_file` is the name of tag info file to write.  If the file exists, it will be overwritten.

The range file has a format like this:

```
<start addr> <end addr> tag_name
...
```

So, for example:

```
0x80000000 0x80010000 Require.Tools.Elf.Section.SHF_EXECINSTR
0x80010000 0x80020000 Require.Tools.Elf.Section.SHF_WRITE
```

The same range can be specified more than once if you wish to apply multiple tags to it.
Ranges may overlap partially as well.

This utility is used to form the base set of tagging information.  In general, to make use
of the tagging information in the validator, you must follow up with `md_code` to put group
tags on instructions in your application.

## `md_code`

The `md_code` utility generates the group tags for instructions in an image.

```
usage: md_code <policy-dir> <code_address> <tag_file>
```

The utility will read a stream of instructions (assumed to be RV32 at this point) from
stdin.  The given `tag_file` will be _updated_ with the group tags for the instructions.
The utility disassembles the input stream and matches the opgroups for the instructions
against group information provided by the policy compiler to develop the appropriate set
of group tags for each concrete instruction.

* `policy_dir` is the directory into which the policy was generated by the policy tool.
* `code_address` is the address at which the stream of instructions from stdin is assumed to be based.
* `tag_file` is the name of the tag file to update.

## `md_asm_ann`

The `md_asm_ann` utility annotates an ASM file listing with string representations of the tags
that have been applied to the instructions.  The ASM file is presumed to be in the format
generated by GNU tools (notably `objdump -dS`).

```
usage: md_asm_ann [flags] policy_dir tag_file asm_file
```
* `policy_dir` is the directory into which the policy was generated by the policy tool.
* `tag_file` is the name of the tag file to update.
* `asm_file` is the name of the ASM file to annotate.

Output will be generated to `<asm_file>.tagged`, if no `--output` flag is given.

## `md_entity`

The `md_entity` utility will generate tagging information for specific logical entities
in a binary image that need to be tagged for one or more policies to function correctly.
For example, if `malloc` needs to be tagged for the heap policy, it will be named as
an entity, and given some metadata to be applied, depending on the combination of
policies being used.

```
usage: md_entity <flags> policy_dir elf_file tag_info_file [entity files]
```
* `policy_dir` is the directory into which the policy was generated by the policy tool.
* `elf_file` is the name of the ELF file that the entities will refer to.
* `tag_info_file` is the name of the tag file to update.

`<flags>` can be:

* `--update=<true/false>` defaults to true, indicates that the `tag_info_file` will be
updated or written from scratch.

Entities are specified by an entities file in YAML format.  By default the tool will process
`policy_dir/policy_entities.yml`, which must always be present, but may be empty (see below).
In addition, `md_entity` will process any additional entity YAML files provided on the
command line.

Entity YAML files have the following format:

```
entities:
  symbol: {
    name: Require.Code.FRTOS.pvPortMalloc
    elf_name: pvPortMalloc,
    tag_all: false
    }
  symbol: {
    name: Require.application.longjmp,
    elf_name: longjmp,
    tag_all: true
    }
  range: {
    name: Require.application.isr
    elf_start: isr_start,
    elf_end:   isr_end
    }
```

There are two types of entity entries allowable:  `symbol` and `range`.  The first specifies the
binding of a named policy entity to some ELF symbol.  If the `tag_all` field is true, then the tool
will mark all words from the start of the symbol to the end, as specified by its size in the ELF file,
with the tag referenced by the entity name.  If the symbol in the ELF file has no size, then an
error is issued.  If the `tag_all` field is false, then only the first word at the given symbol's
address is marked, and the size of the symbol may be zero.

The second type of binding binds a policy entity to the range of addresses delimited by two ELF
symbols.  This is useful for cases where you need to tag ranges of addresses in ASM code, where
the tools cannot know the size of global symbols.

If a particular policy has no named entities that need to be marked, and empty entity YAML file can
be constructed as follows:

```
entities:
```

## `md_index`

The `md_index` utility will construct a list of all unique tags in an existing tag file.
It is invoked as follows:

```
md_index <tag_file> <policy_dir>
```

It will then rewrite the tag file, replacing each tag entry with an offset into the tag list.
For example, `md_index` transforms the following set of tags:

```
{ 0x20400000 - 0x2040002c }: { allGrp }
{ 0x2040002c - 0x20400030 }: { allGrp loadGrp }
{ 0x20400030 - 0x20400034 }: { storeGrp allGrp }
...
```

to the format:

```
Tag value count: 3
0: { allGrp }
1: { allGrp loadGrp }
2: { storeGrp allGrp }

Tag entry count: <number of entries>
{ 0x20400000 - 0x2040002c }: 0
{ 0x2040002c - 0x20400030 }: 1
{ 0x20400030 - 0x20400034 }: 2
...
```

In addition to handling initial tags on memory, `md_index` also initializes tag values on registers
and CSRs.

This step is performed to comply with the tag format used by the PEX firmware. `md_index` is one of
two additional utilities required by the firmware, the other being `md_header`.

## `md_header`

The `md_header` utility will prepend a header to the tag file as needed to initialize the PEX firmware.
This header contains a list of all contiguous regions of mapped memory, divided into code and data sections.
`md_header` takes an ELF binary, a memory map of the SOC, and a tag file as input. It is invoked as follows:

```
md_header <elf_file> <soc_file> <tag_file>
```

The header format is as follows:

```
64-bit? (1B)

# of code ranges (4B)
for each code range:
  start (4B)
  end (4B)

# of data ranges (4B)
for each data range:
  start (4B)
  end (4B)
```

# Scripts

There is one script that can be used used on an ELF format binary to generate tagging information
for an application.

`gen_tag_info` is a python script that uses pyelftools to parse an input ELF file, and calls
both `md_range` and `md_code` to generate tagging information for the RWX policy for the application.
This utility can be expanded upon to add more policy support.  The script uses python3, so make
sure you get the python3 version of pyelftools.  The simplest way to do that is to run:

```sudo pip3 install pyelftools```

# Future

Probably will change md_range to take an option to update an existing tagging file, so that it
can be called multiple times by multiple tools.

