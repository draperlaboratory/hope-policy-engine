#!/usr/bin/env python3

import pdb
import os
import sys
import subprocess
import argparse
import logging
import TaggingUtils
import ELFSectionTagger
import OpCodeTagger
import LLVMMetadataTagger
import yaml

from elftools.elf.elffile import ELFFile
from elftools.elf.constants import SH_FLAGS
from elftools.elf.sections import SymbolTableSection

md_range = 'md_range'
md_code = 'md_code'
md_asm_ann = 'md_asm_ann'
md_entity = 'md_entity'

def policy_has_module(yf, name):
    modules = yf["Modules"]
    for m in modules:
        if m["name"] == name:
            return True
    return False


def write_section_range(ef, range_file, section_name, tag):
    section = ef.get_section_by_name("." + section_name)
    if not section:
        logging.fatal("Couldn't find section {} in elf file!".format(section_name))
    start = section['sh_addr']
    end = start + section['sh_size']
    range_file.write_range(start, end, tag)


def main():
    parser = argparse.ArgumentParser(description='Generate tag ranges file from ELF binary',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("-d", "--policy-dir", action="store", required=True,
                        help="Directory with generated policy yaml")
    parser.add_argument("-t", "--tag-file", action="store", required=True,
                        help="File to output tag info")
    parser.add_argument("-b", "--bin", action="store", required=True,
                        help="Program binary to parse for tags")
    parser.add_argument("--log", action="store", default='WARNING',
                        help="Logging level (DEBUG, WARNING, INFO)")
    parser.add_argument("-e", "--entities", nargs='+', default=[],
                        required=False,
                        help="Entities file for policy")

    args = parser.parse_args()

    asm_file_name = args.tag_file.replace('.taginfo','') + ".text"
    policy_modules = {}

    numeric_level = getattr(logging, args.log.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % args.log)
    logging.basicConfig(level=numeric_level, stream=sys.stderr)

    try:
        if (os.path.isfile(args.tag_file)):
            os.remove(args.tag_file)
    except OSError as err:
        print('could not remove ' + args.tag_file)
        sys.exit(-1)

    with open(args.policy_dir + "/policy_modules.yml", "r") as pmf:
        policy_modules = yaml.load(pmf.read())

    global policy_inits
    with open(args.policy_dir + "/policy_init.yml", "r") as pmf:
        policy_inits = yaml.load(pmf.read())
        
    with open(args.bin, 'rb') as f:
        ef = ELFFile(f)

        range_file = TaggingUtils.RangeFile()

        module_policies = [module['name'].split('.')[-1] for module in policy_modules['Modules']]
        policies = args.policy_dir.split('.')[-1].split('-')

        for policy in policies:
            if policy not in module_policies:
                logging.fatal("Tried to generate tag info for invalid policy")
                sys.exit(-1)
            logging.info("Generating tags for policy {}".format(policy))

            # ELF section tagging
            if 'elf' in policy_inits['Require']:
                ELFSectionTagger.generate_rwx_ranges(ef, range_file)
            
            # LLVM tagging
            if 'llvm' in policy_inits['Require']:
                range_map = LLVMMetadataTagger.generate_policy_ranges(ef, range_file, policy_inits)

        range_file.finish();

        presult = subprocess.call([md_range, args.policy_dir, range_file.name(),
                                   args.tag_file])
        if presult != 0:
            sys.exit(presult)

        range_file.done()

        # Apply opcode tags
        OpCodeTagger.tag_op_codes(args.policy_dir, md_code, ef, args.tag_file)

        # Apply entities
        presult = subprocess.call([md_entity, args.policy_dir, args.bin, args.tag_file] +
                                 args.entities)
        if presult != 0:
            sys.exit(presult)

        # generate the asm file
        with open(asm_file_name, "w") as asm_file:
            presult = subprocess.call(["riscv32-unknown-elf-objdump", "-dS", args.bin],
                                     stdout=asm_file)
            if presult != 0:
                sys.exit(presult)

        # annotate the asm file
        presult = subprocess.call([md_asm_ann, args.policy_dir, args.tag_file,
                                  asm_file_name])
        if presult != 0:
            sys.exit(presult)

if (__name__ == "__main__"):
    main()
