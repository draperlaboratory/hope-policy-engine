#!/usr/bin/env python3

import pdb
import os
import sys
import subprocess
import argparse
import logging
import TaggingUtils
import RWXTagger
import OpCodeTagger
import ELFMetadataTagger
import yaml

from elftools.elf.elffile import ELFFile
from elftools.elf.constants import SH_FLAGS
from elftools.elf.sections import SymbolTableSection

md_range = 'md_range'
md_code = 'md_code'
md_asm_ann = 'md_asm_ann'
md_entity = 'md_entity'

NoCFI = 'dover.Tools.GCC.NoCFI'


def policy_has_module(yf, name):
    modules = yf["Modules"]
    for m in modules:
        if m["name"] == name:
            return True
    return False


def round_up(x, align):
    return ~((~x) & ~align)


def add_code_section_ranges(ef, range_map):
    for s in ef.iter_sections():
        flags = s['sh_flags']
        if (flags & SH_FLAGS.SHF_ALLOC):
            start = s['sh_addr']
            end = start + s['sh_size']
            end = round_up(end, ELFMetadataTagger.PTR_SIZE)
            if ((flags & (SH_FLAGS.SHF_ALLOC | SH_FLAGS.SHF_WRITE | SH_FLAGS.SHF_EXECINSTR)) ==
                (SH_FLAGS.SHF_ALLOC | SH_FLAGS.SHF_EXECINSTR)):
                range_map.add_range(start, end)


def generate_cfi_ranges(ef, range_file):
    code_range_map = TaggingUtils.RangeMap()
    add_code_section_ranges(ef, code_range_map)
    range_map = ELFMetadataTagger.generate_policy_ranges(ef, range_file, "cfi")

    for (start, end, tags) in code_range_map:
        for s in range(start, end, ELFMetadataTagger.PTR_SIZE):
            e = s + ELFMetadataTagger.PTR_SIZE
            if (s, e, tags) not in range_map:
                range_file.write_range(s, e, NoCFI)


def write_section_range(ef, range_file, section_name, tag):
    section = ef.get_section_by_name("." + section_name)
    if not section:
        logging.fatal("Couldn't find section {} in elf file!".format(section_name))
    start = section['sh_addr']
    end = start + section['sh_size']
    range_file.write_range(start, end, tag)


def generate_stack_ranges(ef, range_file):
    ELFMetadataTagger.generate_policy_ranges(ef, range_file, "stack")


def generate_rwx_ranges(ef, range_file):
    RWXTagger.generate_rwx_ranges(ef, range_file)


def generate_cpi_ranges(ef, range_file):
    ELFMetadataTagger.generate_policy_ranges(ef, range_file, "cpi")


def generate_threeClass_ranges(ef, range_file):
    code_range_map = TaggingUtils.RangeMap()
    add_code_section_ranges(ef, code_range_map)
    range_map = ELFMetadataTagger.generate_policy_ranges(ef, range_file, "threeClass")

    for (start, end, tags) in code_range_map:
        for s in range(start, end, ELFMetadataTagger.PTR_SIZE):
            e = s + ELFMetadataTagger.PTR_SIZE
            if (s, e, tags) not in range_map:
                range_file.write_range(s, e, NoCFI)


def main():
    parser = argparse.ArgumentParser(description='Generate tag ranges file from ELF binary',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("-d", "--policy-dir", action="store", required=True,
                        help="Directory with generated policy yaml")
    parser.add_argument("-t", "--tag-file", action="store", required=True,
                        help="File to output tag info")
    parser.add_argument("-b", "--bin", action="store", required=True,
                        help="Program binary to parse for tags")
    parser.add_argument("--log", action="store", default='WARNING',
                        help="Logging level (DEBUG, WARNING, INFO)")
    parser.add_argument("-e", "--entities", nargs='+', default=[],
                        required=False,
                        help="Entities file for policy")

    args = parser.parse_args()

    asm_file_name = args.bin + ".text"
    policy_modules = {}

    numeric_level = getattr(logging, args.log.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % args.log)
    logging.basicConfig(level=numeric_level, stream=sys.stderr)

    try:
        if (os.path.isfile(args.tag_file)):
            os.remove(args.tag_file)
    except OSError as err:
        print('could not remove ' + args.tag_file)
        sys.exit(-1)

    with open(args.policy_dir + "/policy_modules.yml", "r") as pmf:
        policy_modules = yaml.load(pmf.read())

    with open(args.bin, 'rb') as f:
        ef = ELFFile(f)

        range_file = TaggingUtils.RangeFile()

        module_policies = [module['name'].split('.')[-1] for module in policy_modules['Modules']]
        policies = args.policy_dir.split('.')[-1].split('-')

        for policy in policies:
            if policy not in module_policies:
                logging.fatal("Tried to generate tag info for invalid policy")
                sys.exit(-1)
            generate_ranges_func = 'generate_' + policy + '_ranges'
            logging.info("Generating tags for policy {}".format(policy))
            if generate_ranges_func in globals() and callable(globals()[generate_ranges_func]):
                globals()[generate_ranges_func](ef, range_file)
            else:
                print('No such policy generation function: ' + generate_ranges_func + '\n')

        range_file.finish();

        presult = subprocess.call([md_range, args.policy_dir, range_file.name(),
                                   args.tag_file])
        if presult != 0:
            sys.exit(presult)

        range_file.done()

        # Apply opcode tags
        OpCodeTagger.tag_op_codes(args.policy_dir, md_code, ef, args.tag_file)

        # Apply entities
        presult = subprocess.call([md_entity, args.policy_dir, args.bin, args.tag_file] +
                                 args.entities)
        if presult != 0:
            sys.exit(presult)

        # generate the asm file
        with open(asm_file_name, "w") as asm_file:
            presult = subprocess.call(["riscv32-unknown-elf-objdump", "-dS", args.bin],
                                     stdout=asm_file)
            if presult != 0:
                sys.exit(presult)

        # annotate the asm file
        presult = subprocess.call([md_asm_ann, args.policy_dir, args.tag_file,
                                  asm_file_name])
        if presult != 0:
            sys.exit(presult)

if (__name__ == "__main__"):
    main()
